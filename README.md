# EMGtoOMG
An EMG signal to text converter, versions 5.0+ operable for testing with or without a connected user with incoming EMG signals.

# Instructions
Download version 5.1 and the EMGtoOMG.py, then open verison 5.1 in LabView and select EMGtoOMG.py for the module path. Run the program. The program works by switching between different "states" that change based on the user's pattern of inputs. The first encountered state is "inactive": the program will wait for the user to input signal 1 (S1) before it is able to do anything. User clicks on S1 to turn it ON, simulating an incoming EMG signal from a flexing muscle group. User clicks on S1 again to turn it off, simulating the EMG signal stopping and the user relaxing muscle group 1.  
  
The second state encountered is "choose set": the user inputs any combination of two signals (S1, S2, or S3) that match the identity of one of nine sets. Set 1 is a set of proofreading tools, in case of a typo. Sets 2 through 9 contain various alphanumeric characters that make up the entire alphabet and all essential symbols. Refer to the graphic with the nine boxes: the first input signal selects the row, then second input signal selects the column of the desired set. For example: S2, S3 selects the set in the 2nd row and 3rd column, therefore identifying the set containing VWXYZ. At this point, the box corresponding with the chosen set will have a green light as an indicator.  
  
The thrid state encountered is "selection and execution". Here, S3 will cycle through the available alphanumeric characters or proofreading functions. Send as many S3 signals as necessary to select the desired alphanumeric character or function. Once the desired character/function is selected, there are two options to execute the selection. S2 will place the selected character (or trigger the desired function), and remain in the chosen set to quickly access another character, and stay in the "selection and execution" state. S1 will place the selected character, but return the user to the "choose set" state.  
  
"inactive"  
S1 to activate  
S2 does nothing  
S3 does nothing  
  
"choose set"  
send S1 through S3 to select the set row  
send S1 through S3 to select the set column  
  
"selection and execution"  
send S3 repeatedly to find the desired function or alphanumeric character  
send S2 to place selected character, and remain in this state  
send S1 to place selected character, and move back to "choose set" state  
  
This is the basics.

# Premise
This project was completed in the context of a university course on biomedical instrumentation and design. This tool allows a user to operate a text generation software using electrical signals generated by the contraction of their muscles. I was completely responsible for developing and troubleshooting the Python code, developing and troubleshooting the LabView visual code, and learning how Python and LabView interface.

# How it works
The Python code allows the user to navigate through and execute the available alphanumeric characters and text editting functions. LabView is a visual code, and provides the following: it is a proof-of-concept visual user interface, it accepts and filters the incoming electromyography (EMG) signals, it continuously calls specific Python functions to perform its navigation and text selection.


# Challenges
Everything in LabView runs inside of a while loop to run continuously. So, LabView calls the Python functions repeatedly (100s of times per second), and any data stored in variables in each function call are lost. Numeric values passed to the function can be modified within the function, but these modifications do not persist in as LabView continues to run. For example, a variable with an initial value of 1 in LabView is passed to a Python function, the python function adds a 1 and retuns a 2 to LabView, LabView continues, and the 2 never appears, only the original 1. I discovered that Python passes by object reference when calling a function, so storing all variables in LabView as arrays allowed for modifications done in a Python function to have a lasting effect when the call terminated and LabView continued to run.  
Then I discovered that each time a loop in LabView completed, the variable values are reset to their initial values. This was solved by using shift registers, which allow modifications done to a variable during a single loop to be carried into the next loop.  
The team constrained ourselves to only use 3 input signals. I had to make sure each signal was distinct, since each would be coming from a different muscle group. I also decided that only 1 signal should be visible at a time. So, if two muscle groups were being activated simultaneously, only the first one that is triggered would be read by the system. A new signal would not be read until there are no incoming signal

# Version history
1.0 Toying around with the Python Node virtual instrument (VI) to learn how to make Labview and Python talk to each other. This is where I discovered how Python refers to integer and array type variables from LabView, and how to carry-over variables between loops in LabView  
2.0 Created the bones of the text generation code in a Python file, and integrate it into LabView. Add many displays in LabView to track how the Python code is working.  
3.0 Cleaned up the LabView block diagram and slightly modified the front panel  
4.0 Modified the LabView block diagram with a data acquisition VI to read in live EMg signals to use to operate the Python code  
4.1 The same as 4.0, but no live signals are required, instead use buttons to simulate an EMG signal being sent in, then released.
5.0 Removed all unnecessary displays, and added a graphic to help the user visualize what the Python code was doing
5.1 Same as 5.0, but no live signals are required. Instead, use buttons to simulate a signal being sent in when on, and released when off.
